/*
This is the function you need to implement. Quick reference:
- input rows: 0 <= y < ny
- input columns: 0 <= x < x
- element at row y and column x is stored in data[x + y*nx]
- correlation between rows i and row j has to be stored in result[i + j*ny]
- only parts with 0 <= j <= i < ny need to be filled
*/

#include <cmath>
#include <vector>
#include <omp.h>
#include <x86intrin.h>
#include <algorithm>
#include <tuple>

typedef double double4_t __attribute__ ((vector_size (4 * sizeof(double))));
constexpr double4_t d4zero = {0,0,0,0};
// helper functions
inline double horizontal_sum(double4_t vec) {
    return vec[0] + vec[1] + vec[2] + vec[3];
}


static inline double4_t sqrt_vector(double4_t v) {
    double4_t r = {0.0, 0.0, 0.0, 0.0};
    for (int i = 0; i < 4; ++i) {
        r[i] = std::sqrt(v[i]);
    }
    return r;
}

static inline double4_t swap2(double4_t x) { return _mm256_permute2f128_pd(x, x, 0b00000001); }
static inline double4_t swap1(double4_t x) { return _mm256_permute_pd(x, 0b00000101); }

void correlate(int ny, int nx, const float *data, float *result) {

    constexpr int blockCols = 4;
    constexpr int blockRows = 8;

    const int vecCols = (nx + blockCols - 1) / blockCols;
    const int vecRows = (ny + blockRows - 1) / blockRows;
    const int paddedRows = vecRows * blockRows;

    std::vector<double4_t> vd(paddedRows * vecCols, d4zero);
    
    #pragma omp parallel for
    for (int y = 0; y < paddedRows; y++) {
        for (int x = 0; x < vecCols; x++) {
            for (int v = 0; v < blockCols; v++) {
                int col = x * blockCols + v;
                vd[x + y * vecCols][v] = col < nx && y < ny ? data[col + y * nx] : 0;
            }
        }
    }

    #pragma omp parallel for
    for (int y = 0; y < ny; y++) {
        double4_t sumVec = d4zero;
        double4_t squareSumVec = d4zero;
    
        for (int x = 0; x < vecCols; x++) {
            double4_t val = vd[y * vecCols + x];
            sumVec += val;
            squareSumVec += val * val;
        }
    
        double totalSum = horizontal_sum(sumVec);
        double totalSquareSum = horizontal_sum(squareSumVec);
    
        double mean = totalSum / nx;
        double stddev = std::sqrt(totalSquareSum / nx);

        double4_t meanVec = {mean, mean, mean, mean};
        double4_t stddevVec = {stddev, stddev, stddev, stddev};
    
        for (int x = 0; x < vecCols; x++) {
            vd[y * vecCols + x] = (vd[y * vecCols + x] - meanVec) / stddevVec;
        }
        
        // Step 3: Zero out padded values (if any) in last block
        int lastBlockStart = (vecCols - 1) * 4;
        for (int v = 0; v < 4; v++) {
            int col = lastBlockStart + v;
            if (col >= nx) {
                vd[(y * vecCols) + (vecCols - 1)][v] = 0.0;
            }
        }
    }

    #pragma omp parallel for schedule(dynamic)
    for (int ia = 0; ia < vecRows; ++ia) {
        for (int ja = ia; ja < vecRows; ++ja) {
            // We need a 4x4 block of correlations
            double4_t z00 = d4zero;
            double4_t z01 = d4zero;
            double4_t z10 = d4zero;
            double4_t z11 = d4zero;

            // Calculate dot products
            for (int k = 0; k < vecCols; ++k) {
                double4_t a00 = vd[vecCols * ia + k];
                double4_t b00 = vd[vecCols * ja + k];
                double4_t a10 = swap2(a00);
                double4_t b01 = swap1(b00);

                z00 = z00 + (a00 * b00);
                z01 = z01 + (a00 * b01);
                z10 = z10 + (a10 * b00);
                z11 = z11 + (a10 * b01);
            }

            // Store results in array for easier access
            double4_t z[4] = {z00, z01, z10, z11};
            
            // Adjust odd-indexed blocks
            for (int kb = 1; kb < blockCols; kb += 2) {
                z[kb] = swap1(z[kb]);
            }

            // Copy results to output array
            for (int jb = 0; jb < blockCols; ++jb) {
                for (int ib = 0; ib < blockCols; ++ib) {
                    int i = ib + blockCols * ia;
                    int j = jb + blockCols * ja;
                    
                    // Only fill the upper triangular part and check bounds
                    if (j < ny && i < ny && i <= j) {
                        result[i + j * ny] = z[ib ^ jb][jb];
                    }
                }
            }
        }
    }
    
}


/*
This is the function you need to implement. Quick reference:
- input rows: 0 <= y < ny
- input columns: 0 <= x < nx
- element at row y and column x is stored in data[x + y*nx]
- correlation between rows i and row j has to be stored in result[i + j*ny]
- only parts with 0 <= j <= i < ny need to be filled
*/

#include <cmath>
#include <vector>
#include <omp.h>
#include <x86intrin.h>
#include <algorithm>
#include <tuple>


typedef double double4_t __attribute__ ((vector_size (4 * sizeof(double))));

// helper functions
inline double horizontal_sum(__m256d vec) {
    __m128d hi = _mm256_extractf128_pd(vec, 1);
    __m128d lo = _mm256_castpd256_pd128(vec);
    __m128d sum1 = _mm_add_pd(hi, lo);
    __m128d sum2 = _mm_hadd_pd(sum1, sum1);
    return _mm_cvtsd_f64(sum2);
}

double r_mean(const float* row, int nx) {
    __m256d sum_vec = _mm256_setzero_pd();
    int j = 0;

    for (; j + 4 <= nx; j += 4) {
        __m128 float_vals = _mm_loadu_ps(&row[j]);
        __m256d double_vals = _mm256_cvtps_pd(float_vals);
        sum_vec = _mm256_add_pd(sum_vec, double_vals);
    }

    double sum = horizontal_sum(sum_vec);

    // Handle remaining elements
    for (; j < nx; ++j) {
        sum += static_cast<double>(row[j]);
    }

    return sum / static_cast<double>(nx);
}

// Standard deviation function - SIMD optimized
double r_std(const float* row, int nx, double mean) {
    __m256d square_sum_vec = _mm256_setzero_pd();
    const __m256d mean_vec = _mm256_set1_pd(mean);
    int j = 0;

    for (; j + 4 <= nx; j += 4) {
        __m128 float_vals = _mm_loadu_ps(&row[j]);
        __m256d double_vals = _mm256_cvtps_pd(float_vals);
        __m256d diff = _mm256_sub_pd(double_vals, mean_vec);
        square_sum_vec = _mm256_fmadd_pd(diff, diff, square_sum_vec); // diff^2 + sum
    }

    double square_sum = horizontal_sum(square_sum_vec);

    // Handle remaining elements
    for (; j < nx; ++j) {
        double diff = static_cast<double>(row[j]) - mean;
        square_sum += diff * diff;
    }

    return std::sqrt(square_sum);
}


static inline double4_t swap2(double4_t x) { return _mm256_permute2f128_pd(x, x, 0b00000001); }
static inline double4_t swap1(double4_t x) { return _mm256_permute_pd(x, 0b00000101); }


void correlate(int ny, int nx, const float *data, float *result) {
    int nb = 4;
    int na = (ny + nb - 1) / nb;
    double4_t* vector_data = static_cast<double4_t*>(_mm_malloc(sizeof(double4_t) * na * nx, 32));
    
    const int KBLOCK = 64;

    
    #pragma omp parallel for schedule(static, 1)
    for (int i = 0; i < ny; ++i) {
        const float* row = &data[i * nx];
        double mean = r_mean(row, nx);
        double stddev = r_std(row, nx, mean);
        
        int ia = i / nb;
        int ib = i % nb;

        double4_t mean_vec = {mean, mean, mean, mean};
        double4_t std_vec  = {stddev, stddev, stddev, stddev};

        asm("# loop1 starts here");
        int j = 0;
        for (; j + 4 <= nx; j += 4) {
            float tmp[4];
            tmp[0] = row[j];
            tmp[1] = row[j + 1];
            tmp[2] = row[j + 2];
            tmp[3] = row[j + 3];

            double4_t vals = {
                static_cast<double>(tmp[0]),
                static_cast<double>(tmp[1]),
                static_cast<double>(tmp[2]),
                static_cast<double>(tmp[3])
            };

            double4_t norm_vals = (vals - mean_vec) / std_vec;

            vector_data[nx * ia + j + 0][ib] = norm_vals[0];
            vector_data[nx * ia + j + 1][ib] = norm_vals[1];
            vector_data[nx * ia + j + 2][ib] = norm_vals[2];
            vector_data[nx * ia + j + 3][ib] = norm_vals[3];
        }
        asm("# loop1 ends here");

        for (; j < nx; ++j) {
            double norm_val = (static_cast<double>(row[j]) - mean) / stddev;
            vector_data[nx * ia + j][ib] = norm_val;
        }
    }
    
    

    asm("# loop2 starts here");
    #pragma omp parallel for schedule(dynamic,1)
    for (int ia = 0; ia < na; ++ia) {
        for (int ja = ia; ja < na; ++ja) {

            double4_t vv[4] = {
                {0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0}
            };

            int ia_base = nx * ia;
            int ja_base = nx * ja;

            #pragma omp simd aligned(vector_data:32) simdlen(4)
            for (int kb = 0; kb < nx; kb += KBLOCK) {
                int kend = std::min(kb + KBLOCK, nx);
                for (int k = kb; k < kend; ++k) {
                    constexpr int PF = 12;
                    __builtin_prefetch(&vector_data[ia_base + k + PF]);
                    __builtin_prefetch(&vector_data[ja_base + k + PF]);

                    double4_t a = vector_data[ia_base + k];
                    double4_t b = vector_data[ja_base + k];

                    double4_t a_swapped = swap2(a);
                    double4_t b_swapped = swap1(b);

                    vv[0] = vv[0] + (a * b);
                    vv[1] = vv[1] + (a * b_swapped);
                    vv[2] = vv[2] + (a_swapped * b);
                    vv[3] = vv[3] + (a_swapped * b_swapped);
                }
            }

            vv[1] = swap1(vv[1]);
            vv[3] = swap1(vv[3]);

            for (int jb = 0; jb < nb; ++jb) {
                for (int ib = 0; ib < nb; ++ib) {
                    int i = ib + nb * ia;
                    int j = jb + nb * ja;
                    if (j < ny && i < ny && i <= j) {
                        result[ny * i + j] = vv[ib ^ jb][jb];
                    }
                }
            }
        }
    }
    asm("# loop2 ends here");
    _mm_free(vector_data);
}